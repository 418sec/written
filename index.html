<!dOCTYPE html>
<html>
  <head>
      <link rel='stylesheet' href='written.css' />
      <script src='written.js'></script>

      <link rel='stylesheet' href='prism.css' />
      <script src='prism.js'></script>

      <link rel='stylesheet' href='main.css' />
  </head>
  <body>

    <header>
      <h1><a href='http://pothibo.github.com/written'>Written</a></h1>
      <a href="https://github.com/pothibo/written"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>
      <nav>
      <a href='markdown.html'>Markdown Syntax</a>
      <a href='parsers.html'>Configure Parsers</a>
      </nav>
    </header>

    <main>
      <section>
        <nav>
          <a href='javascript:void(0);'>Markdown</a>
          <a href='javascript:void(0);' data-selected>Rendered</a>
        </nav>
        <div class='rendered'></div>
        <div class='editor'>Written is the editor you _need_ if you wish to have a *standalone, customizeable, live markdown editor* on your site. Markdown comes in different flavor, for that reason, you might want to have a look at [the list of markdown parsers enabled by default with Written](markdown.html). By default, Written supports the following syntax:
- Headers;
- Unordered lists;
- Ordered lists;
- Quotes;
- Block-level and inline code snippets (The code highlighting is done by third party like [Prism.js](http://prismjs.com/download.html));
- Images;
- Links;
- Bold words;
- Italic words;
To get started with Written, you just need to add the standalone file to your project and initialize your editor.
~~~javascript main.js
editor = new Written(el)
~~~
For Written to work as expected, you *need to include the CSS file that comes with it*. The content of the editor can be retrieve manually or it can update automatically an input field that is determined in advance.
### Manually get the content of the editor
~~~javascript
document.querySelector('#Editor').instance.history.current.toHTMLString()
~~~
### Listen for changes
~~~javascript main.js
editor = new Written(el)
el.addEventListener('written:changed', function(event) {
  event.detail.document.toString() // Markdown version
  event.detail.document.toHTMLString() // Rendered version
})
~~~
## Under the hood
Using technologies like Mutation Observers, Written was built to be supported by all evergreen browsers.
This editor is build around 3 concepts:
1. Documents
2. Parsers
3. Attachments
Those concepts are bound together through the core of Written which handles the boilerplate algorithms and event handling like undo/redo, keystroke inputs, copy/paste, etc.
Here's a description of the 3 concepts and how they work to make this editor works the way it does:
## Documents
Documents are basically immutable objects that store a sort of abstract tree of the content as well as the cursor position. With that data, a text is built and rendered on the page.
On each keystroke, a new document is created. Then, the document looks at the DOM and through a _diffing_ algorithm, it efficiently changes the DOM so that the editor renders the document as it should be.
Every documents created are pushed on top of the history tree so the core can come back to it in case a user needs to come back to a previous version. This is how the undo/redo functionality is implemented.
## Parsers
Parsers are split into two categories: *block* and *inline* parsers. Before this point, the editor is pretty much language agnostic. It could be implemented to parse any kind of content. By default, the parsers are built to parse Markdown, or a version of it.
### Block parsers
The block parsers have options that can help customize their behaviour. Some of them may want to grab only 1 line of text, like headers, and some other might need be configured to support multiline support, like the ordered list above.
Also, block parsers could want from the editor _not_ to parse their inner content. One such case would be a code block parser where the content of the code snippet requires to be kept intact (and code highlighted, maybe?).
### Inline parsers
Inline parsers are much more straightforward, they are triggered on some rules and change their content to something else. Think of all the words here that are either bold, italic. These are inline parsers.
### Cherry-pick your parsers
With Written, you can select what parser you want to enable. This way, you decide what feature to enable for your user. For example, if you'd wish to only support headers and italic and bold parsers, here how you would do it:
~~~javascript
var parsers = new Written.Parsers({
  blocks: ['header'],
  inlines: ['italic', 'bold']
})
new Written(el, {parsers: parsers});
~~~
You can look at the [parser](/parsers.html) page for more information.
## Add Written to your project
~~~javascript main.js
new Written(el)
~~~
## A final note
This text is entirely editable. You can edit it to your liking to test the different feature Written supports.
Enjoy :)</div>
      </section>
    </main>

    <footer>
      <link href='https://fonts.googleapis.com/css?family=Dancing+Script' rel='stylesheet' type='text/css'>
      <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700,400italic' rel='stylesheet' type='text/css'>
      <link href='https://fonts.googleapis.com/css?family=Lora:700,700italic' rel='stylesheet' type='text/css'>
      <script src='main.js'></script>
    </footer>
  </body>
</html>
